program{
    
}

type TipoDePago is variant {
/* PROP: modelar Tipos de pago aceptados */
case Tarjeta {}
case MartPago {}
case Efectivo {}
}
type Producto is record{
/* PROP: modelar productos
INV.REP.: precio > 0 */
field nombre // String
field marca // String
field precio // Número
}
type Cliente is record {
/* PROP: modelar clientes */
field dni // String
field tipoDePago // TipoDePago
field productos // [Producto]
}
type Caja is record {
/* PROP: modelar cajas
INV.REP.: número > 0
facturado >= 0 */
field número // Número
field clientesEsperando // [Cliente]
field aceptaPagos // [TipoDePago]
field esRápida // Bool
field facturado // Número
}
-----------------------------------------------------------------------------------------------------------------
function cantidadDeClientesEsperandoEn_(unaCaja){
    /*
    Proposito:
        Describe la cantidad de clientes que estan esperando en la caja dada
    Precondicion:
        ninguna
    Tipo:Numero
    Paramentro:
        *unaCaja*:Caja
    */
    cantidadDeClientesEsperando:=0
    foreach clientes in clientesEsperando(unaCaja){
        cantidadDeClientesEsperando := cantidadDeClientesEsperando + 1
    }
    return(cantidadDeClientesEsperando)
    
}
-----------------------------------------------------------------------------------------------------------------
function cajaMenosOcupadaDe_(cajas){
    /*
    Proposito:
        Describe la caja que tiene menos clientes esperando en las cajas *cajas*,si hay mas de una caja que tiene
        la misma cantidad de clientes esperando, describe la primera que encuentre.
    Precondicion:
        tiene que haber al menos una caja en la lista dada
    Tipo:Caja
    Paramentro:
        *cajas*:[Caja]
    */
    cajaConMenosClientesHastaAhora := primero(cajas)
    foreach caja in cajas{
        cajaConMenosClientesHastaAhora := caja_TieneMenosClientesEsperandoQue_(cajaConMenosClientesHastaAhora,caja)
    }
    return(cajaConMenosClientesHastaAhora)
    
}

function caja_TieneMenosClientesEsperandoQue_(primeraCaja,segundaCaja){
    /*
    Proposito:
        Describe la caja con menos clientes esperando entre las cajas dadas
    Precondicion:
        ninguna
    Tipo:Caja
    Paramentro:
        primeraCaja,segundaCaja: Caja
    */
    
    return(
            choose  primeraCaja     when(cantidadDeClientesEsperandoEn_(primeraCaja)>= cantidadDeClientesEsperandoEn_(segundaCaja))
                    segundaCaja     otherwise
        )
    
}
-----------------------------------------------------------------------------------------------------------------
//C)
function gobsMart_conIngresoDe_aCaja_(listaDeCajas,cliente,numeroCaja){
    /*
    Proposito:
        Describe la misma lista de cajas dada pero actualizando la caja del 
        número dado para registrar que el cliente dado ingresó en la misma
    Precondicion:
        la caja con el numero *numeroCaja* tiene que estar en la lista de caja *listaDeCajas*
    Tipo:[Caja]
    Paramentro:
        *listaDeCajas*:[Caja]
        *cliente*:Cliente
        *numeroCaja*:Numero
    */
    listaDeCajasHastaAhora := listaDeCajas
    primeraParteDeLaLista:=[]
    while(not esVacía(listaDeCajasHastaAhora) && not es_ElNumeroDeLaCaja_(numeroCaja,primero(listaDeCajasHastaAhora)) ){
        primeraParteDeLaLista := primeraParteDeLaLista ++ [primero(listaDeCajasHastaAhora)]
        listaDeCajasHastaAhora := resto(listaDeCajasHastaAhora)
    }
    return(
        primeraParteDeLaLista ++ [
            agregarAlCliente_ALaCaja_(cliente,caja_ConNumeroModificadopPor_(primero(listaDeCajasHastaAhora),numeroCaja))
            ] ++ resto(listaDeCajasHastaAhora)
        )
    
}

function agregarAlCliente_ALaCaja_(cliente,caja){
    /*
    Proposito:
        Describe la caja dada con el cliente en la lista de clientes esperando
    Precondicion:
        ninguna
    Tipo:
        Caja
    Paramentro:
        *caja*:Caja
        *numeroCaja*:Numero
    */
    return(
            Caja(caja | clientesEsperando <- clientesEsperando(caja) ++ [cliente])
        )
}

function caja_ConNumeroModificadopPor_(caja,numeroDeCaja){
    /*
    Proposito:
        Describe la caja dada pero con el numero modificado por *numeroDeCaja*
    Precondicion:
        ninguna
    Tipo:
        Caja
    Paramentro:
        *caja*:Caja
        *numeroCaja*:Numero
    */
    return(
            Caja(caja | número <- numeroDeCaja)
        )
}

function es_ElNumeroDeLaCaja_(numeroDeCaja,caja){
    /*
    Proposito:
        Indica si el numero *numeroDeCaja* es el mismo de la caja dada
    Precondicion:
        ninguna
    Tipo:
        Booleano
    Paramentro:
        *caja*:Caja
        *numeroCaja*:Numero
    */
    return(
            numeroCaja == número(caja)
        )
}

------------------------------------------------------------------------------------------------------------------
//d
function gobsMart_conIngresosDe_(listaDeCajas,listaDeCliente){
    /*
    Proposito:
        Describe una lista de cajas actualizada, donde cada cliente de la lista
    dada ingresó a una caja que acepta el medio de pago que posee, y que esté
    menos ocupada en el momento que ingresa.
    Precondicion:
        Ninguna
    Tipo:[Caja]
    Paramentro:
        *listaDeCajas*:[Caja]
        *cliente*:[Cliente]
    */
    listaDeCajasHastaAhora := listaDeCajas
    
    foreach cliente in listaDeCliente{
        
        listaDeCajasHastaAhora := 
            gobsMart_conIngresoDe_aCaja_(listaDeCajasHastaAhora,cliente,número(cajaMenosOcupadaDe_(cajas_ConTipoDePago_(listaDeCajas,tipoDePago(cliente)))))
    }
    
    
    return(listaDeCajasHastaAhora)
    
}

function cajas_ConTipoDePago_(listaDeCajas,tipoDePago){
    /*
    Proposito:
        Describe la lista de cajas *listaDeCajas* pero con solamente con el tipo de pago *tipoDePago*,
        sino hay ninguna entonces describe una lista vacia
    Precondicion:
        Ninguna
    Tipo:[Caja]
    Paramentro:
        *listaDeCajas*:[Caja]
        *tipoDePago*:TipoDePago
    */
    listaDeCajasConElTipoDePago := []
    foreach caja    in  listaDeCajas{
        listaDeCajasConElTipoDePago := listaDeCajasConElTipoDePago ++ singular_Si_(caja,contiene_A_(aceptaPagos(caja),TipoDePago))
    }
    return(listaDeCajasConElTipoDePago)
}

function contiene_A_(lista,elementoAVerificar){
    /*
    Proposito
        Indica si en la lista *lista* se encuentra el elemento *elementoAVerificar*
    Precondicion
        ninguna
    Tipo:
       Booleano
    Parametro:
        lista: [Elemento]
        elementoAVerificar: Elemento
    */
    listaHastaAhora:=lista
    
    while(not esVacía(listaHastaAhora) && not primero(listaHastaAhora)==elementoAVerificar ){
        listaHastaAhora:= resto(listaHastaAhora)
    }
    
    return(not esVacía(listaHastaAhora) && primero(listaHastaAhora)==elementoAVerificar)
}
--------------------------------------------------- E) ---------------------------------------------------------------


function sumatoriaDe_(listaDeNúmeros){
/*PROPÓSITO: Describe la suma de todos los elementos de la lista dada, si la lista es
vacía devuelve 0.
PRECONDICIONES: ninguna
PARÁMETROS: *listaDeNúmeros*:[Numero]
RESULTADO: Número.
*/
    sumatoria:=0
    foreach numero in listaDeNúmeros{
        sumatoria := sumatoria + numero
    }
    return(sumatoria)
}


function caja_conPrimeroFacturado(caja){
    /*
    Proposito:
        Describe la caja resultante de facturar al primero de los clientes de la caja dada
        (o sea, el cliente se retiró y la caja actualizó sus datos).
    Precondicion:
        Ninguna
    Tipo:[Caja]
    Paramentro:
        *caja*:Caja
    Observaciones:
        Se puede suponer que el cliente eligió bien la caja
        de acuerdo a su tipo de pago.
    */
    listaDeClientesDeLaCaja := clientesEsperando(caja)
    montoFacturado:=0
    if(not esVacía(listaDeCajasHastaAhora)){
        montoFacturado := montoTotalDelCliente_(primero(listaDeCajasHastaAhora))
    }
    
    return(
        Caja(caja | facturado <- facturado(caja) + montoFacturado,clientesEsperando <- resto(listaDeClientesDeLaCaja))
        )
}

function montoTotalDelCliente_(cliente){
    /*
    Proposito:
        Describe el monto total de los productos que tiene el cliente dada.
    Precondicion:
        Ninguna
    Tipo:
        Numero
    Paramentro:
        cliente:Cliente
    */
    montoFacturadoHastaAhora := 0
    foreach producto in productos(cliente){
        montoFacturadoHastaAhora := montoFacturadoHastaAhora + precio(producto)
    }
    
    return(montoFacturadoHastaAhora)
}

--------------------------------------------------- F) ---------------------------------------------------------------
function gobsMart_conCliente_cambiaACaja_(listaDeCajas,dniCliente,numeroDeCaja){
    /*
    Proposito:
        Describe la lista de cliente dada actualizada, cambiando al cliente con el dni *dniCliente* a la caja con el numero *numeroDeCaja*
    Precondicion:
        El cliente con el dni dado tiene que estar en alguna caja de la lista dada
    Tipo:
        [Caja]
    Paramentro:
        *listaDeCajas*:[Caja]
        *dniCliente*:String
        *numeroDeCaja*:Numero
    */
    cajaConElCliente := clienteConElDni_EnLasCajas_(dniCliente,listaDeCajas) //solo lo pongo en una variable para que quede mas claro
    
    return(
        gobsMart_conIngresoDe_aCaja_(gobsMart_conEgresoDe_aCaja_(listaDeCajas,cajaConElCliente,numeroCaja),cajaConElCliente,numeroCaja)
        )
    
}

function gobsMart_conEgresoDe_aCaja_(listaDeCajas,cliente,numeroCaja){
    /*
    Proposito:
        Describe la misma lista de cajas dada pero actualizando la caja del 
        número *numeroCaja* para sacar al cliente *cliente* que estaba en la misma
    Precondicion:
        la caja con el numero *numeroCaja* tiene que estar en la lista de caja *listaDeCajas*
    Tipo:[Caja]
    Paramentro:
        *listaDeCajas*:[Caja]
        *cliente*:Cliente
        *numeroCaja*:Numero
    */
    listaDeCajasHastaAhora := []
    foreach caja in listaDeCajas{
        listaDeCajasHastaAhora := listaDeCajasHastaAhora ++ sinCliente_SiCaja_Es_(cliente,caja,numeroCaja)    
    }
    
    return(listaDeCajasHastaAhora)
}

function sinCliente_SiCaja_Es_(cliente,caja,numeroCaja){
    /*
    Proposito:
        Describe la caja *caja* con el numero *numeroCaja* sin el cliente *cliente*, sino describe la caja *caja*
        sin modificaciones
    Precondicion:
        ninguna
    Tipo:Caja
    Paramentro:
        *listaDeCajas*:[Caja]
        *cliente*:Cliente
        *numeroCaja*:Numero
    */
    
    return(
            choose  sinCliente_EnLaCaja_  when( número(caja) == numeroCaja )
                    caja    otherwise
        )
}

function sinCliente_EnLaCaja_(clienteASacar,caja){
    /*
    Proposito:
        Describe la caja *caja* sin el cliente *cliente*
    Precondicion:
        El cliente *cliente* tiene que estar en la caja dada
    Tipo:Caja
    Paramentro:
        *listaDeCajas*:[Caja]
        *clienteASacar*:Cliente
    */
    clientesEsperandoHastaAhora:=[]
    foreach cliente in clientesEsperando(caja){
        clientesEsperandoHastaAhora := clientesEsperandoHastaAhora ++ singular_Si_(cliente, dni(clienteASacar) /= dni(cliente))
    }
    return(clientesEsperandoHastaAhora)
}

function clienteConElDni_EnLasCajas_(dniCliente,listaDeCajas){
    /*
    Proposito:
        Describe el cliente con el dni *dniCliente* que se encuentra en la lista *listaDeCajas*, sino
        lo encuentra describe una lista vacia
    Precondicion:
        El cliente con el dni *dniCliente* tiene que estar en alguna caja de la lista dada
    Tipo:
        Cliente
    Paramentro:
        *listaDeCajas*:[Caja]
        *dniCliente*:String
    */
    listaDeCajasHastaAhora := listaDeCajas
    clientesEsperandoCaja :=[]
    while(not esVacía(listaDeCajasHastaAhora) && esVacía(clientesEsperandoCaja)){
        clientesEsperandoCaja := clientesEsperandoCaja ++ clienteConElDni_EnListaDeEspera_(dniCliente,clientesEsperando(primero(listaDeCajasHastaAhora)))
        listaDeCajasHastaAhora := resto(listaDeCajasHastaAhora)
    }
    
    return(primero(clientesEsperandoCaja))
}
function clienteConElDni_EnListaDeEspera_(dniCliente,clientesEsperando){
    /*
    Proposito:
        Describe el cliente con el dni *dniCliente* que se encuentra en la lista *clientesEsperando*, sino
        lo encuentra describe una lista vacia
    Precondicion:
        ninguna
    Tipo:
        [Cliente]
    Paramentro:
        *listaDeCajas*:[Cliente]
        *dniCliente*:String
    */
    clienteEsperando:=[]
    foreach cliente in clientesEsperando{
        clienteEsperando := clienteEsperando ++ singular_Si_(cliente,esCliente_ConDni_(cliente,dniCliente))
    }
    return(clienteEsperando)
} 

function esCliente_ConDni_(cliente,dni){
    /*
    Proposito:
        Indica si el cliente dado tiene el dni dado
    Precondicion:
    ninguna
    Tipo:
        Booleano
    Paramentro:
        *cliente*:Cliente
        *dni*:String
    */
    return(
        dni(cliente) == dni
        )
}













